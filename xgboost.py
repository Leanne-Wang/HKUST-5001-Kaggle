# -*- coding: utf-8 -*-
"""Xgboost.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w2gK1pWC7K7J0UsbrQmwXmYAhHP2h9Vy
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import xgboost as xgb
import glob
from sklearn.metrics import mean_squared_error, mean_absolute_error

# %matplotlib inline
plt.rcParams['font.sans-serif'] = 'SimHei' 
plt.rcParams['axes.unicode_minus'] = False  
plt.rcParams['figure.dpi'] = 200  
plt.rcParams['text.color'] = 'black'  
plt.style.use('ggplot')
print(plt.style.available) 
'''
['bmh', 'classic', 'dark_background', 'fast', 'fivethirtyeight', 'ggplot', 'grayscale', 'seaborn-bright', 'seaborn-colorblind', 'seaborn-dark-palette', 'seaborn-dark', 'seaborn-darkgrid', 'seaborn-deep', 'seaborn-muted', 'seaborn-notebook', 'seaborn-paper', 'seaborn-pastel', 'seaborn-poster', 'seaborn-talk', 'seaborn-ticks', 'seaborn-white', 'seaborn-whitegrid', 'seaborn', 'Solarize_Light2', 'tableau-colorblind10', '_classic_test']
'''

train = pd.read_csv('filled_2017(1).csv')
test = pd.read_csv('filled_2018(1).csv')
#print(train)
#test=train.iloc[7900:8760, :]
#train=train.iloc[0:7900, :]
train['date']=pd.to_datetime(train.date,format='%d/%m/%Y %H:%M',errors='coerce')
test['date']=pd.to_datetime(test.date,format='%d/%m/%Y %H:%M',errors='coerce')
test=test.sort_values(by = ['date'],axis = 0,ascending = True)

train_all=pd.concat([train,test])
print(train_all)
train_all.dtypes
train_all['speed_behind'] = train_all['speed'].shift(-1)
train_all['speed_ahead'] = train_all['speed'].shift(1)
test['speed_behind'] = test['speed'].shift(-1)
test['speed_ahead'] = test['speed'].shift(1)
print(train_all)

def create_features(df):
    df['hour'] = df['date'].dt.hour
    df['dayofweek'] = df['date'].dt.dayofweek
    df['quarter'] = df['date'].dt.quarter
    df['month'] = df['date'].dt.month
    df['year'] = df['date'].dt.year
    df['dayofyear'] = df['date'].dt.dayofyear
    df['dayofmonth'] = df['date'].dt.day
    df['weekofyear'] = df['date'].dt.weekofyear
    df['holiday']=df['holiday']
    df['speed_ahead']=df['speed_ahead']
    df['speed_behind']=df['speed_behind']

    X = df[['hour','dayofweek','quarter','month','year',
           'dayofyear','dayofmonth','weekofyear','holiday','speed_ahead','speed_behind']]
    return X

X_train, y_train = create_features(train_all), train_all['speed']
X_test, y_test   = create_features(test), test['speed']
X_train.shape, y_train.shape

reg=xgb.XGBRegressor(n_estimators=1000)
reg.fit(X_train, y_train, eval_set=[(X_train, y_train), (X_test, y_test)], early_stopping_rounds=50)

_ = xgb.plot_importance(reg, height=0.9)

def mean_absolute_percentage_error(y_true, y_pred): 
    """Calculates MAPE given y_true and y_pred"""
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

test['Prediction'] = reg.predict(X_test)
print(test['Prediction'])
mse = mean_squared_error(y_true=test['speed'], y_pred=test['Prediction'])
map= mean_absolute_percentage_error(y_true=test['speed'], y_pred=test['Prediction'])
print(mse)
print(map)
c=pd.DataFrame({'id':test['id'], 'speed':test['Prediction']})
c=c.sort_values(by = ['id'],axis = 0,ascending = True)
c=c.iloc[0:3504]
print(c)

final_test_csv_path = 'test.csv'
final_test_csv = pd.read_csv(final_test_csv_path)
submission = []


submission = pd.DataFrame(c, columns=('id', 'speed'))
submission.to_csv('submissionXgboost.csv', index=False)

temp_all = pd.concat([test, train], sort=False)
_ = temp_all[['speed','Prediction']].plot(figsize=(15, 5))

test['error'] = test['speed'] - test['Prediction']
test['abs_error'] = test['error'].apply(np.abs)
#error_by_day = test.groupby(['year','month','dayofmonth']).mean()[['speed','Prediction','error','abs_error']]
#error_by_day.sort_values('abs_error', ascending=False).head(10)
error_by_day = test.groupby(['year','month','dayofmonth','hour']).mean()[['speed','Prediction','error','abs_error']]
error_by_day.sort_values('abs_error', ascending=False).head(10)